<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Let there be (gl)Light!</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">
		<link rel="stylesheet" href="plugin/highlight/zenburn.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Let there be (gl)Light!</h2>
					<h4>A glimpse in real-time 3D graphics world</h4>
				</section>

				<section>
					<h4>Real-time 3D graphics what?</h4>
					<img height="500" src="image/focus.svg" />
				</section>

				<section>
					<h4>Rasterization engine</h4>
					<img height="400" src="image/wireframe.svg" />
					<p>Rasterize &raquo; render to pixels &raquo; render 3D triangles</p>
				</section>

				<section>
					<section>
						<h4>Render 3D triangle</h4>
						<img height="350" src="image/projection.svg" />
						<p>Project 3D world points &raquo; 2D screen space</p>
					</section>

					<section>
						<h4>Perspective projection</h4>
						<p>
							\[
							\begin{bmatrix}
							P_x \\ P_y
							\end{bmatrix}
							=
							\begin{bmatrix}
							O_x
							\\
							O_y
							\end{bmatrix}
							* tan(fov) / O_z
							\]
						</p>
						<ul>
							<li><em>P<sub>z</sub></em> also computed and used for depth test</li>
							<li>Display projected points such as:</li>
						</ul>
						<p>\[(P_x, P_y, P_z) &isin; ([-1, 1], [-1, 1], [-1, 1])\]</p>
					</section>
				</section>

				<section>
					<p>Demo 01: projection</p>
					<p>Demo 02: rotation</p>
				</section>

				<section>
					<h4>Projections made easy</h4>
					<ul>
						<li>Move &amp; rotate model?</li>
						<li>Relocate camera?</li>
					</ul>
					<div>
						<img height="300" src="image/world-to-view.png" />
					</div>
					<p>Transformation matrices üôå</p>
				</section>

				<section>
					<h4>Changing coordinate system</h4>
					<ul>
						<li>
							Translate point by vector <em>t</em>:
							\[
							\begin{bmatrix}
							p'_x \\ p'_y \\ p'_z
							\end{bmatrix}
							=
							\begin{bmatrix}
							p_x \\ p_y \\ p_z
							\end{bmatrix}
							+
							\begin{bmatrix}
							t_x \\ t_y \\ t_z
							\end{bmatrix}
							\]
						</li>
						<li>
							Rotate point of angle <em>Œ∏</em> around <em>x</em> axis:
							\[
							\begin{bmatrix}
							p'_x \\ p'_y \\ p'_z
							\end{bmatrix}
							=
							\begin{bmatrix}
							1 & 0 & 0 \\
							0 & cos(Œ∏) & sin(Œ∏) \\
							0 & -sin(Œ∏) & cos(Œ∏)
							\end{bmatrix}
							*
							\begin{bmatrix}
							p_x \\ p_y \\ p_z
							\end{bmatrix}
							\]
						</li>
					</ul>
				</section>

				<section>
					<h4>Compose transforms</h4>
					<p>
						\[
						\begin{bmatrix}
						p'_x \\ p'_y \\ p'_z \\ w'
						\end{bmatrix}
						=
						\begin{bmatrix}
						rot_{11} & rot_{12} & rot_{13} & tr_1 \\
						rot_{21} & rot_{22} & rot_{23} & tr_2 \\
						rot_{31} & rot_{32} & rot_{33} & tr_3 \\
						0 & 0 & 0 & 1
						\end{bmatrix}
						*
						\begin{bmatrix}
						p_x \\ p_y \\ p_z \\ 1
						\end{bmatrix}
						\]
					</p>
					<p>
						Rotate by A then translate by B then rotate by C:
						\[P' = A * B * C * P\]
					</p>
				</section>

				<section>
					<p>Demo 03: composition</p>
				</section>

				<section>
					<p>Rasterizing triangles</p>
					<div class="r-stack">
						<img height="400" src="image/scanline-1.svg" />
						<img height="400" src="image/scanline-2.svg" class="fragment fade-in" data-fragment-index="1" />
						<img height="400" src="image/scanline-3.svg" class="fragment fade-in" data-fragment-index="2" />
					</div>
					<p class="fragment fade-in" data-fragment-index="2">
						\[
						s1
						=
						\begin{bmatrix}
						b1_x + (a_x - b1_x) * h / (b1_y - a_y)
						\\
						a_y + h
						\end{bmatrix}
						\]
					</p>
				</section>

				<section>
					<p>Demo 04: rasterization</p>
				</section>

				<section>
					<p>High CPU cost:</p>
					<ul>
						<li>Matrix & vector instructions</li>
						<li>Interpolate pixels</li>
					</ul>
					<p class="fragment" data-fragment-index="1">Parallelize on GPU!</p>
				</section>

				<section>
					<p>Meet <s>Open</s> WebGL:</p>
					<p>Rendering-oriented &amp; GPU-designed API</p>
					<aside class="notes">
						<ul>
							<li>Jan 1992: released by Silicon Graphics</li>
							<li>2006: managed by Khronos Group</li>
							<li>Cross-platform &amp; language independant API</li>
							<li>Wildly used, supported, documented</li>
							<li>Superseeded by Vulkan since 2016</li>
						</ul>
					</aside>
				</section>

				<section>
					<p>The WebGL pipeline</p>
					<div style="background: white;">
						<img height="200" src="image/gl-pipeline.png" />
					</div>
					<p>Customize with <em>shader</em> programs</p>
				</section>

				<section>
					<p>Demo 05: WebGL</p>
				</section>

				<section>
					<p>Lack realism üò¢</p>
					<div>
						<img height="300" src="image/lighting-off.jpg" />
						<img height="300" src="image/lighting-on.jpg" />
					</div>
					<ul>
						<li>Simulate material properties</li>
						<li>Require lighting computation</li>
					</ul>
				</section>

				<section>
					<section>
						<p>Phong model</p>
						<div>
							<img height="400" src="image/shad2-roughsurface.png" />
						</div>
						<ul>
							<li>Empirical BRDF approximation</li>
							<li>Diffuse + specular components</li>
						</ul>
						<aside class="notes">
							<ul>
								<li>BRDR = Bidirectional Reflectance Distribution Function</li>
								<li>4 variables: radiance, irradiance, light angle, normal</li>
								<li>Bui Tuong Phong, 1975</li>
								<li>Blinn-Phong variant (Jim Blinn, 1977) used to be OpenGL & DirectX default</li>
							</ul>
						</aside>
					</section>

					<section>
						<p>Physically-based rendering models</p>
						<div>
							<img height="150" src="image/ndf.png" />
						</div>
						<ul>
							<li>Based on the theory of microfacets</li>
							<li>Cook-Torrance BRDF mostly used</li>
						</ul>
						<aside class="notes">
							<ul>
								<li>Explored by Disney</li>
								<li>Approximate real world physical properties (conservation of energy, fresnel
									reflectivity, etc.)</li>
								<li>Introduced for real-time display by Epic Games in UE4+</li>
							</ul>
						</aside>
					</section>
				</section>

				<section>
					<p>Tricks to improve final result:</p>
					<ul>
						<li>Normal mapping</li>
						<li>Height mapping</li>
					</ul>
					<div>
						<img height="350" src="image/maps.jpg" />
					</div>
					<aside class="notes">
						<ul>
							<li>Normal mapping: perturb normals using 2D texture</li>
							<li>Height mapping: simulate height on flat surfaces</li>
						</ul>
					</aside>
				</section>

				<section>
					<p>Demo 06: forward Phong rendering</p>
					<p>Demo 07: forward PBR rendering</p>
				</section>

				<section>
					<p>\[O(nbLights * nbModels) üò•\]</p>
					<img height="350" src="image/deferred_example.png" />
					<p>Want hundreds of lights?</p>
				</section>

				<section>
					<section>
						<p>Deferred shading</p>
						<ul>
							<li>StarCraft II, GTA IV, CryENGINE3...</li>
							<li>Multi-step rendering pipeline:
								<ol>
									<li>Draw models, store depth, normal &amp; material</li>
									<li>Process lights for the whole geometry at once</li>
								</ol>
							</li>
						</ul>
						<p>\[O(nbLights + nbModels) üòÅ\]</p>
						<aside class="notes">
							<ul>Reconstruct point from depth + buffer coordinates</ul>
							<ul>Apply lighting from point + stored material properties</ul>
							<ul>Limitation: no transparency, rigid material support</ul>
						</aside>
					</section>

					<section>
						<p>Deferred lighting</p>
						<ul>
							<li>BioShock Infinite, Assassin's Creed 3, MGS V...</li>
							<li>Multi-step rendering pipeline:
								<ol>
									<li>Draw models, store depth &amp; normal</li>
									<li>Draw lights &amp; store radiance data</li>
									<li>Draw models again and apply lights to surfaces</li>
								</ol>
							</li>
						</ul>
						<p>\[O(nbLights + nbModels) üòÅ\]</p>
						<aside class="notes">
							<ul>Better material flexibility than deferred shading</ul>
							<ul>2 passes per model instead of 1</ul>
						</aside>
					</section>
				</section>

				<section>
					<p>Demo 08: deferred shading</p>
					<p>Demo 09: deferred lighting</p>
				</section>

				<section>
					<p>That's all folks!</p>
				</section>

				<section>
					<p>Resources:</p>
					<ul>
						<li><a href="https://glumpy.github.io/modern-gl.html">Model OpenGL</a></li>
						<li><a
								href="https://blenderartists.org/forum/showthread.php?401209-Cycles-Parallax-(step)-mapping-shader-with-Silhouette-Occlusion-Download">Blender
								Artists</a></li>
						<li><a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">LearnOpenGL - Deferred
								Shading</a></li>
						<li><a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Phong reflection model</a>
						</li>
						<li><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF">The
								Phong Model and the concepts of Illumination Models and BRDF</a></li>
						<li><a href="http://webreference.com/3d/lesson18/part2.html">3D Animation Workshop</a></li>
						<li><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">OpenGL Projection Matrix</a>
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/math/math.js"></script>
		<script src="plugin/highlight/highlight.js"></script>

		<script>
			Reveal.initialize({
				history: true,
				plugins: [
					RevealMarkdown,
					RevealHighlight,
					RevealMath.KaTeX,
					RevealNotes
				],
				transition: 'convex'
			});
		</script>
	</body>
</html>